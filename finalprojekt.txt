import os
import sqlite3
import numpy as np
import matplotlib.pyplot as plt
from sklearn.linear_model import LinearRegression
import tkinter as tk
from tkinter import messagebox
import bcrypt
from datetime import datetime

# Datenbankmodul
def setup_database():
    conn = sqlite3.connect("finance_manager.db")
    cursor = conn.cursor()

    cursor.execute("""
    CREATE TABLE IF NOT EXISTS users (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        username TEXT UNIQUE NOT NULL,
        password TEXT NOT NULL
    )
    """)

    cursor.execute("""
    CREATE TABLE IF NOT EXISTS budgets (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        user_id INTEGER NOT NULL,
        category TEXT NOT NULL,
        amount REAL NOT NULL,
        FOREIGN KEY (user_id) REFERENCES users (id)
    )
    """)

    cursor.execute("""
    CREATE TABLE IF NOT EXISTS expenses (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        user_id INTEGER NOT NULL,
        category TEXT NOT NULL,
        amount REAL NOT NULL,
        date TEXT NOT NULL,
        FOREIGN KEY (user_id) REFERENCES users (id)
    )
    """)

    conn.commit()
    conn.close()

setup_database()

# Validierungsmodule
def is_valid_date(date_str):
    """Prüft, ob das Datum im Format YYYY-MM-DD korrekt ist."""
    try:
        datetime.strptime(date_str, "%Y-%m-%d")
        return True
    except ValueError:
        return False

def validate_inputs(category, amount, date=None):
    """Validiert die Benutzereingaben."""
    if not category.strip():
        messagebox.showerror("Error", "Category cannot be empty")
        return False
    if not amount.replace('.', '', 1).isdigit() or float(amount) <= 0:
        messagebox.showerror("Error", "Amount must be a positive number")
        return False
    if date and not is_valid_date(date):
        messagebox.showerror("Error", "Invalid date format. Use YYYY-MM-DD")
        return False
    return True

# Authentifizierungsmodul
class Auth:
    def __init__(self):
        self.conn = sqlite3.connect("finance_manager.db")

    def hash_password(self, password):
        """Hash das Passwort mit bcrypt."""
        return bcrypt.hashpw(password.encode('utf-8'), bcrypt.gensalt())

    def verify_password(self, hashed_password, password):
        """Überprüft, ob das Passwort mit dem Hash übereinstimmt."""
        return bcrypt.checkpw(password.encode('utf-8'), hashed_password)

    def register(self):
        register_window = tk.Tk()
        register_window.title("Register")

        tk.Label(register_window, text="Username:").grid(row=0, column=0)
        username_entry = tk.Entry(register_window)
        username_entry.grid(row=0, column=1)

        tk.Label(register_window, text="Password:").grid(row=1, column=0)
        password_entry = tk.Entry(register_window, show="*")
        password_entry.grid(row=1, column=1)

        def handle_register():
            username = username_entry.get()
            password = password_entry.get()

            if not username or not password:
                messagebox.showerror("Error", "Username and password cannot be empty")
                return

            hashed_password = self.hash_password(password)

            cursor = self.conn.cursor()
            try:
                cursor.execute("INSERT INTO users (username, password) VALUES (?, ?)", (username, hashed_password))
                self.conn.commit()
                messagebox.showinfo("Success", "Registration successful!")
                register_window.destroy()
            except sqlite3.IntegrityError:
                messagebox.showerror("Error", "Username already exists")

        tk.Button(register_window, text="Register", command=handle_register).grid(row=2, columnspan=2)
        register_window.mainloop()

    def login(self):
        login_window = tk.Tk()
        login_window.title("Login")

        tk.Label(login_window, text="Username:").grid(row=0, column=0)
        username_entry = tk.Entry(login_window)
        username_entry.grid(row=0, column=1)

        tk.Label(login_window, text="Password:").grid(row=1, column=0)
        password_entry = tk.Entry(login_window, show="*")
        password_entry.grid(row=1, column=1)

        def handle_login():
            username = username_entry.get()
            password = password_entry.get()

            if not username or not password:
                messagebox.showerror("Error", "Username and password cannot be empty")
                return

            cursor = self.conn.cursor()
            cursor.execute("SELECT id, password FROM users WHERE username = ?", (username,))
            user = cursor.fetchone()

            if user and self.verify_password(user[1], password):
                messagebox.showinfo("Success", "Login successful!")
                self.user_id = user[0]
                login_window.destroy()
            else:
                messagebox.showerror("Error", "Invalid credentials")

        tk.Button(login_window, text="Login", command=handle_login).grid(row=2, columnspan=2)
        tk.Button(login_window, text="Register", command=self.register).grid(row=3, columnspan=2)
        login_window.mainloop()
        return hasattr(self, 'user_id')
# Budget-Manager-Modul
class BudgetManager:
    def __init__(self, root, user_id):
        self.root = root
        self.user_id = user_id
        self.conn = sqlite3.connect("finance_manager.db")
        self.create_window()

    def create_window(self):
        budget_window = tk.Toplevel(self.root)
        budget_window.title("Budget Manager")

        tk.Label(budget_window, text="Category:").grid(row=0, column=0)
        category_entry = tk.Entry(budget_window)
        category_entry.grid(row=0, column=1)

        tk.Label(budget_window, text="Amount:").grid(row=1, column=0)
        amount_entry = tk.Entry(budget_window)
        amount_entry.grid(row=1, column=1)

        def add_budget():
            category = category_entry.get()
            amount = amount_entry.get()

            if validate_inputs(category, amount):
                try:
                    cursor = self.conn.cursor()
                    cursor.execute("INSERT INTO budgets (user_id, category, amount) VALUES (?, ?, ?)",
                                   (self.user_id, category, float(amount)))
                    self.conn.commit()
                    messagebox.showinfo("Success", "Budget added successfully!")
                except sqlite3.Error as e:
                    messagebox.showerror("Error", f"Database error: {e}")

        tk.Button(budget_window, text="Add Budget", command=add_budget).grid(row=2, columnspan=2)

# Expense-Tracker-Modul
class ExpenseTracker:
    def __init__(self, root, user_id):
        self.root = root
        self.user_id = user_id
        self.conn = sqlite3.connect("finance_manager.db")
        self.create_window()

    def create_window(self):
        expense_window = tk.Toplevel(self.root)
        expense_window.title("Expense Tracker")

        tk.Label(expense_window, text="Category:").grid(row=0, column=0)

        # Dropdown für Kategorien
        category_var = tk.StringVar(expense_window)
        category_dropdown = self.create_category_dropdown(expense_window, category_var)
        category_dropdown.grid(row=0, column=1)

        tk.Label(expense_window, text="Amount:").grid(row=1, column=0)
        amount_entry = tk.Entry(expense_window)
        amount_entry.grid(row=1, column=1)

        tk.Label(expense_window, text="Date (YYYY-MM-DD):").grid(row=2, column=0)
        date_entry = tk.Entry(expense_window)
        date_entry.grid(row=2, column=1)

        def add_expense():
            category = category_var.get()
            amount = amount_entry.get()
            date = date_entry.get()

            if validate_inputs(category, amount, date):
                try:
                    cursor = self.conn.cursor()
                    cursor.execute("INSERT INTO expenses (user_id, category, amount, date) VALUES (?, ?, ?, ?)",
                                   (self.user_id, category, float(amount), date))
                    self.conn.commit()
                    messagebox.showinfo("Success", "Expense added successfully!")
                except sqlite3.Error as e:
                    messagebox.showerror("Error", f"Database error: {e}")

        tk.Button(expense_window, text="Add Expense", command=add_expense).grid(row=3, columnspan=2)

    def create_category_dropdown(self, parent, category_var):
        """Erstellt ein Dropdown mit den Kategorien des Nutzers."""
        cursor = self.conn.cursor()
        cursor.execute("SELECT DISTINCT category FROM budgets WHERE user_id = ?", (self.user_id,))
        categories = [row[0] for row in cursor.fetchall()]

        if not categories:
            categories = ["No categories available"]

        category_var.set(categories[0])  # Standardwert setzen
        return tk.OptionMenu(parent, category_var, *categories)
# Visualisierungs-Modul
class Visualizer:
    def __init__(self, root, user_id):
        self.root = root
        self.user_id = user_id
        self.conn = sqlite3.connect("finance_manager.db")
        self.create_window()

    def create_window(self):
        viz_window = tk.Toplevel(self.root)
        viz_window.title("Visualizer")

        def plot_data():
            cursor = self.conn.cursor()
            cursor.execute("SELECT category, SUM(amount) FROM expenses WHERE user_id = ? GROUP BY category", 
                           (self.user_id,))
            data = cursor.fetchall()

            if not data:
                messagebox.showerror("Error", "No data to visualize")
                return

            categories = [row[0] for row in data]
            amounts = [row[1] for row in data]

            plt.figure(figsize=(8, 6))
            plt.bar(categories, amounts, color='skyblue')
            plt.xlabel("Category")
            plt.ylabel("Total Amount")
            plt.title("Expenses by Category")
            plt.xticks(rotation=45, ha="right")
            plt.tight_layout()
            plt.show()


        tk.Button(viz_window, text="Show Chart", command=plot_data).pack(pady=10)

# Machine-Learning-Forecaster
class MLForecaster:
    def __init__(self, root, user_id):
        self.root = root
        self.user_id = user_id
        self.conn = sqlite3.connect("finance_manager.db")
        self.create_window()

    def create_window(self):
        forecast_window = tk.Toplevel(self.root)
        forecast_window.title("Expense Forecaster")

        def forecast():
            cursor = self.conn.cursor()
            cursor.execute("SELECT date, amount FROM expenses WHERE user_id = ?", (self.user_id,))
            data = cursor.fetchall()

            if len(data) < 2:
                messagebox.showerror("Error", "Not enough data to forecast")
                return

            # Vorbereitung der Daten
            dates = np.array([int(d.replace("-", "")) for d, _ in data]).reshape(-1, 1)
            amounts = np.array([a for _, a in data])

            # Lineare Regression
            model = LinearRegression()
            model.fit(dates, amounts)

            # Zukünftige Datenpunkte
            future_dates = np.array([dates[-1][0] + i * 100 for i in range(1, 4)]).reshape(-1, 1)
            predictions = model.predict(future_dates)

            # Ergebnisse plotten
            plt.figure(figsize=(8, 6))
            plt.scatter(dates, amounts, color='blue', label='Actual Data')
            plt.plot(np.vstack((dates, future_dates)), 
                     np.hstack((model.predict(dates), predictions)), color='red', linestyle='--', label='Forecast')
            plt.xlabel("Date (as YYYYMMDD)")
            plt.ylabel("Amount")
            plt.title("Expense Forecast")
            plt.legend()
            plt.tight_layout()
            plt.show()

        tk.Button(forecast_window, text="Forecast Expenses", command=forecast).pack(pady=10)

def validate_inputs(*inputs):
    """Validiert Benutzereingaben."""
    for value in inputs:
        # Check if the input is empty
        if not value or value.strip() == "":
            messagebox.showerror("Error", "All fields must be filled")
            return False

        # Check if the value is a valid number (supports negative values and decimal points)
        try:
            float_value = float(value)
        except ValueError:
            messagebox.showerror("Error", f"Invalid input: {value}. Must be a valid number.")
            return False
        
        # Optionally, we can add additional checks (like restricting negative amounts, etc.)
        # if float_value < 0:
        #     messagebox.showerror("Error", f"Invalid input: {value}. Amount cannot be negative.")
        #     return False

    return True

